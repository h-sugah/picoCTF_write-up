# Java Script Kiddie 2
Author: John Johnson  

### URL
https://play.picoctf.org/practice/challenge/33. 

#### Description
The image link appears broken... twice as badly...  
Additional details will be available after launching your challenge instance.  

<br>
<br>
<br>
<br>

## 解答の過程
「Launch Instance」ボタンを押してインスタンスを起動します。  
追加の文章が表示されます。  

```
The image link appears broken... twice as badly...
http://fickle-tempest.picoctf.net:56702
```

追加された文章にはURLが記載されています。  
クリックしてアクセスします。  

テキスト入力欄とSubmitボタンがあるシンプルなページが表示されます。  
試しに、「pico」と入力してSubmitボタンを押すと、画像を表示しようとして失敗している状態になります。  
開発者モードにしてソースコードを確認すると、入力した内容に基づいてpngファイルへのパスを作成しているようです。  

![challenge-33--figure1](pictures/challenge-33--figure1.png)

ヒントを参照するとJavaScript problemと書かれているので、ソースコードに記述されているJavaScriptのコードを解析します。

```
<script>
	var bytes = [];
	$.get("bytes", function(resp) {
		bytes = Array.from(resp.split(" "), x => Number(x));
	});    ＜＝＝＝ サーバーからデータを取得しています。取得したデータは、スペース区切りの文字列になっているので、スペースで分割して数値に変換しています。

	function assemble_png(u_in){    ＜＝＝＝ 入力した文字列を受け取り関数を開始しています。
		var LEN = 16;
		var key = "00000000000000000000000000000000";    ＜＝＝＝ キーとして扱うようです。
		var shifter;
		if(u_in.length == key.length){    ＜＝＝＝ 入力した文字列の長さがkey.lengthと一致すれば、入力した文字列がキーになります。つまり、32文字入力することにります。
			key = u_in;
		}
		var result = [];
		for(var i = 0; i < LEN; i++){
			shifter = Number(key.slice((i*2),(i*2)+1));    ＜＝＝＝ keyの偶数番目の文字を取り出し、数値に変換します。
			for(var j = 0; j < (bytes.length / LEN); j ++){
				result[(j * LEN) + i] = bytes[(((j + shifter) * LEN) % bytes.length) + i]    ＜＝＝＝ 取得したバイトデータをブロックに分けて、shifter分ずらしてresultにセットしています。
			}
		}
		while(result[result.length-1] == 0){
			result = result.slice(0,result.length-1);
		}    ＜＝＝＝ resultの末尾が0のものを削除していってます。
		document.getElementById("Area").src = "data:image/png;base64," + btoa(String.fromCharCode.apply(null, new Uint8Array(result)));    ＜＝＝＝ resultを文字列に変換しています。
		return false;
	}
</script>
```

以上の解析内容から、正しいkeyとなる32文字分の数字を入力することで、レスポンスで得られるbytesのデータを並べ替え、PNGデータとして表示させていることが分かります。  
「Java Script Kiddie」ではkeyが16文字でしたが、こちらの問題は32文字になっています。しかし、LEN = 16であり、Number()が偶数インデックスの文字を数値に変換するので、奇数インデックスはどのような値でも問題ないことになります。  

「Java Script Kiddie」と同じ方法でbytesデータから正しいkeyとなる値を見つけていけば良いことになります。  
bytesデータは、アクセスしたページで開発者モードにして「Console」タブを選択し、プロンプト上に「bytes」と入力してEnterキーを押します。  
これでbytesデータの内容が表示されますので、コピーします。  

PNGデータはヘッダーに8バイトのシグネチャーを持ち、16進数での値は「89 50 4E 47 0D 0A 1A 0A」になります。そして、ファイルヘッダーの後にはIHDRチャンクがあり、シグネチャーの次の8バイトは「00 00 00 0D 49 48 44 52」で固定されています。  
つまり、最初の16バイト分は決まった値であり、この16バイト分の値を手掛かりに導き出せばよいことになります。  
最初の16バイト分の値を10進数で並べると、以下になります。  

> 137, 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82

keyを導き出す考え方は以下のようになります。  
- result[0]～result[15]の値がPNGデータの最初の16バイト分です。  
- bytes[]からresult[]をセットしている箇所とループiとjの関係から、j = 0のときを検討します。
- このとき、result[i] = bytes[(shifter * 16) % 732 + i]になるので、i = 0 ～ 15のときにresult[]とbytes[]が一致するshifterの値を求めます。
- shifterは0 ～ 9です。

この考え方に基づいて、shifter（key）を導き出す処理をPythonで作成します。  
なお、bytesデータが732バイトあるため、shifter（key）が複数存在する可能性があり、それを意識して作成します。  
bytes[]は、Chromeブラウザーの開発者モードで出力したbytesデータをコピー＆ペーストして用意できます。  

[KeyFinder.py]  
```
bytes = [ 248,131,78,68,249,39,74,178,243,19,228,157,247,215,168,119,76,29,1,71,126,125,108,180,163,0,242,200,225,95,169,141,17,155,0,114,128,58,29,191,139,0,249,0,148,175,253,73,189,224,69,2,4,98,169,168,170,0,111,13,39,222,175,78,212,69,14,223,181,121,255,130,219,120,89,0,119,0,121,231,96,80,78,150,108,84,128,10,6,41,231,237,0,0,0,0,198,0,57,12,245,150,96,114,0,163,93,165,0,72,0,0,119,0,239,107,174,64,26,65,0,22,0,9,73,192,68,82,73,16,129,252,13,66,1,72,1,20,0,244,0,193,95,108,137,148,179,122,0,10,68,6,84,214,0,206,155,29,109,220,0,39,44,145,159,0,246,24,1,73,156,215,72,7,184,36,164,243,57,70,68,73,1,125,196,206,192,72,63,31,146,178,48,59,238,89,165,4,10,43,30,89,1,204,14,239,32,134,215,227,174,222,200,108,43,31,251,255,18,90,59,7,188,243,98,23,102,81,226,202,171,72,96,249,14,143,49,51,32,183,51,141,88,61,159,51,153,10,36,52,183,242,55,53,73,18,206,83,135,61,156,120,245,182,61,1,19,173,231,243,66,227,111,125,72,23,78,223,233,175,152,105,239,243,143,59,95,195,196,140,230,22,234,245,150,21,231,191,56,14,243,229,243,169,140,102,95,182,64,59,119,158,223,176,79,255,81,249,44,102,151,249,108,239,55,154,211,151,144,120,223,60,199,54,93,249,127,165,31,48,2,199,200,238,110,122,31,196,69,23,178,148,208,205,81,175,64,22,196,162,194,253,27,167,199,219,19,121,100,180,100,165,206,190,223,175,79,50,123,93,194,143,8,216,242,34,75,64,211,239,26,31,53,248,243,28,80,81,243,123,49,136,61,254,128,175,194,125,153,49,109,244,48,103,186,227,152,243,252,47,83,216,243,220,175,90,234,18,199,176,99,248,241,82,118,87,77,77,74,106,71,0,62,219,43,208,238,77,210,231,200,58,76,191,54,146,46,115,106,233,108,255,18,32,97,228,127,223,178,61,113,127,105,113,226,43,59,14,241,10,191,254,127,79,7,191,215,225,106,186,222,74,68,224,30,191,138,247,187,79,234,1,154,47,25,235,193,241,154,215,174,254,155,86,221,25,149,159,223,4,22,74,175,23,26,204,77,102,231,223,185,15,95,166,126,55,126,107,58,0,61,243,40,245,120,158,91,135,235,90,226,223,233,140,62,76,143,74,251,242,177,158,126,197,135,113,206,228,163,13,58,245,217,122,38,30,19,145,250,178,161,25,250,147,118,155,26,62,19,140,219,255,205,186,47,121,202,148,254,227,98,215,59,60,157,90,92,251,110,3,171,223,202,111,133,43,242,226,35,248,139,160,205,212,78,111,4,199,240,175,203,88,247,160,253,201,55,115,155,141,95,117,38,165,150,251,64,136,157,93,124,141,159,241,78,190,114,215,217,117,52,114,147,181,154,251,46,190,225,61,123,102,220,61,210,131,132,118,102,105,35,199,245,111,80,205,206,239,197,31,254,169,236,46,86,240,54,238,158,175,186,238,216,242,254,176,127,206,104,229,237,143,2,103,188,156,80,18,127,75,197,86,78,2,230,38,248,29,230,121,147,218,92,23,138,124 ]
result = [ 137, 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82 ]

for i in range(16):
    print(f"{i}文字目のkey候補：", end=" ")
    for key_candidate in range(10):
        if result[i] == bytes[key_candidate * 16 + i]:
            print(f" {key_candidate}", end="")
    print("")


> python3 keyFinder.py 
0文字目のkey候補：  9 
1文字目のkey候補：  5 
2文字目のkey候補：  0  5 
3文字目のkey候補：  1 
4文字目のkey候補：  8 
5文字目のkey候補：  9 
6文字目のkey候補：  7 
7文字目のkey候補：  5 
8文字目のkey候補：  6  7 
9文字目のkey候補：  1  2  3 
10文字目のkey候補：  7  8  9 
11文字目のkey候補：  3 
12文字目のkey候補：  7 
13文字目のkey候補：  6 
14文字目のkey候補：  7 
15文字目のkey候補：  7 
```

2文字目と8文字目の候補になる数値が2種類、9文字目と10文字目の候補になる数値が3種類なので、2×2×3×3 = 36通りの文字列になります。  
keyとなる文字列の奇数インデックスはどのような値でも構わないので、0にします。  
これで、以下のような組み合わせの文字列が考えられます。

```
1. 90500010809070506010703070607070
2. 90500010809070506010803070607070
3. 90500010809070506010903070607070
4. 90500010809070506020703070607070
5. 90500010809070506020803070607070
6. 90500010809070506020903070607070
7. 90500010809070506030703070607070
8. 90500010809070506030803070607070
9. 90500010809070506030903070607070
10. 90500010809070507010703070607070
11. 90500010809070507010803070607070
12. 90500010809070507010903070607070
13. 90500010809070507020703070607070
14. 90500010809070507020803070607070
15. 90500010809070507020903070607070
16. 90500010809070507030703070607070
17. 90500010809070507030803070607070
18. 90500010809070507030903070607070
19. 90505010809070506010703070607070
20. 90505010809070506010803070607070
21. 90505010809070506010903070607070
22. 90505010809070506020703070607070
23. 90505010809070506020803070607070
24. 90505010809070506020903070607070
25. 90505010809070506030703070607070
26. 90505010809070506030803070607070
27. 90505010809070506030903070607070
28. 90505010809070507010703070607070
29. 90505010809070507010803070607070
30. 90505010809070507010903070607070
31. 90505010809070507020703070607070
32. 90505010809070507020803070607070
33. 90505010809070507020903070607070
34. 90505010809070507030703070607070
35. 90505010809070507030803070607070
36. 90505010809070507030903070607070
```

上記のkey候補を順番に入力してみます。  
14番目のkey候補を入力した段階で、QRコードが表示されました。  

![challenge-33--figure2](pictures/challenge-33--figure2.png)

このQRコードをGoogleレンズでスキャンします。Chromeブラウザーであれば、QRコードを右クリックして表示されるポップアップメニューの中に「Googleでこの画像について質問する」のような項目が存在するので、それを選択します。  
検索結果の中に、スキャンされたフラグ文字列が存在するのでコピーして回答します。  

<br>
<br>
<br>
<br>

## フラグ
picoCTF{c1f4f2d57d0538d4e9e2ab53e3d1fedc}  

