# b00tl3gRSA2
Author: invisibility  

### URL
https://play.picoctf.org/practice/challenge/2  

### Description
In RSA d is a lot bigger than e, why don't we use d to encrypt instead of e? Connect with nc jupiter.challenges.picoctf.org 19566.  

<br>
<br>

## 解答の過程
問題文に記載されているサイトへncコマンドで接続すると、以下のような出力が得られます。  

```
> nc jupiter.challenges.picoctf.org 19566

c: 28626740034579465027670150160172370356257005637199903127587036179210392208293539864649798888156051522270789214068353807897291359389555614241404626181268787642367108795960498763680410863436801501919345373451143786175286880800232816595943415218414068739588819026399482209880292859951145670529734021262147744478
n: 56529413884631229467508117362661669275454645931203625765600676159911831729436064090203402462722346175198938805163808146123590937748297410962113941879589822818295787224287571463374684437964662796384628742865818753141948614072070898657766874638464068990439143111392008979631193202602071153016152622260341921491
e: 36012627357023337374276079283587703952263712441425188509385443800486425782926974256222931416163704093271448098850941512562461590276167130095659233523273174910508580741333341243766627001942632683486516730423049815370260067574066093460492472823591878736700168516419104498350669402184613725099600945209872875873
```

RSA暗号方式の暗号化と復号の式は以下のように現わされます。  

暗号化：c = m^e (mod n)  

復号：m = c^d (mod n)  

ここで、cは暗号文、mはメッセージ、eとnは公開鍵、dとnは秘密鍵になります。  

公開鍵（n, e）  
秘密鍵（n, d）  
と表現します。  

ncコマンドで得られたc、n、eより、メッセージmを使って暗号化し、cを得たのだと考えられます。復号すればmが得られるので、それがフラグになると思われます。  
しかし、dが分かりません。  

問題文には、「dはeより非常に大きな値である。なぜ暗号化するのにeを使ってdを使わないのか」、ということが書かれています。  
eは、「公開指数」とか「公開鍵指数」と呼ばれており、誰でも知っていて良い数値のことです。一般的に、eは65537が使われます。  

ncコマンドで表示されたeの値は、65535より非常に大きい値なので、この問題はdとeを逆に使ったのではないかと考えられます。つまり、非常に大きい値のはずであるdをeとして使って暗号化したのです。そして、公開鍵のつもりでc、n、eを出力した、ということになります。この考えに従うと、dを公開指数とみなして、d=65537の値で復号してみれば良いことになります。  

そこで、以下に示すようなPythonのコードを作成しました。  

```
c = 28626740034579465027670150160172370356257005637199903127587036179210392208293539864649798888156051522270789214068353807897291359389555614241404626181268787642367108795960498763680410863436801501919345373451143786175286880800232816595943415218414068739588819026399482209880292859951145670529734021262147744478
n = 56529413884631229467508117362661669275454645931203625765600676159911831729436064090203402462722346175198938805163808146123590937748297410962113941879589822818295787224287571463374684437964662796384628742865818753141948614072070898657766874638464068990439143111392008979631193202602071153016152622260341921491
d = 65537

m = pow(c, d, n)  # m = c^d mod nを計算する。
print("int: ", m)

m = hex(m)[2:] # この後の処理で「0x」が邪魔なので取り除きます。
print("hex: ", m)

m = bytes.fromhex(m).decode('utf-8')
print("str: ", m)
```

実行すると以下のように出力され、フラグを得ることができました。  

```
> python decrypt.py
int:  180638594769037903267909311328535969949661653321164402927482237
hex:  7069636f4354467b6261645f31643361355f323433383132357d
str:  picoCTF{bad_1d3a5_2438125}
```

<br>
<br>
<br>
<br>

## フラグ
Flag: picoCTF{bad_1d3a5_2438125}  

